import fs from 'fs';
/*import pino from 'pino';

const logger = pino({
  transport: {
    targets: [
      {
        target: 'pino-pretty',
        options: {
          colorize: true,
          destination: 1
        }
      },
      {
        target: 'pino/file',
        options: {
          destination: './logs/app.log',
          mkdir: true
        }
      }
    ]
  }
});*/

export class BotCommandError extends Error {
    static PublicErrorMessages = {

    }
    $identifier: string;
    constructor(identifier: string, ...arg: any[]) {
        super(...arg)
        this.$identifier = identifier
    }
    sendErrorMessage() {

    }
}

export type MyLibRGB = [ number, number, number ];
export class MyLib {
    static getPaddingOp (
        char: string, 
        length: number, 
        preprocess: ($:any) => string = $ => String($),
        postprocess : ($:string[]) => string[] = $ => $
    ): ((c:any) => string) {
        return function(raw: any): string {
            raw = preprocess(raw);
            return postprocess([char.repeat(Math.max(0, length - raw.length)), raw]).join()
        }
    }
    static readonly TerminalFormatTarget = {
        background: 30,//'38',
        text: 40,//'48'
    } as const;
    
    static readonly TerminalColorMode = {
        full:   [8,2],
        byte:   [8,5],
        bit3:   [0,-1],
        bit4:   [0,-2],
    } as const;
    static CreateTextColorOp(
        target: keyof typeof this.TerminalFormatTarget,
        rgb: MyLibRGB,
        colorMode: keyof typeof this.TerminalColorMode
    ) {
        
        const intensediff   = 60;
        const base_code = [...colorMode];
        base_code[0] += target;
        const reset_code    = '\x1b[0m';

        
        const color_code    = 
        return function(text: string) {
            return `${color_code}${text}${reset_code}`
        }
    }
    static CreateTerminalOp(type: keyof typeof this.TerminalTargetCode, color: string) {
        return `\x1b[${this.TerminalTargetCode[type]};${color}`;
        
    }
    static getTerminalColorOp(mode: string): (...$:any[]) => string {
        switch(mode) {
            
            default:
                return function(): string {
                    return ``;
                }
        }
    }
}

export class LocalLogManager { 
    #LOG_FILE_FORMAT: string;
    #MAX_LOGFILE_LINE_COUNT: number;

    savestream:    NodeJS.WritableStream;
    viewstream: NodeJS.WritableStream;
    getTimeStamp(format: string, DateObject: Date = new Date()) {
        
        const head4 = this.getPaddingOp('0', 4);
        const head2 = this.getPaddingOp('0', 2);
        const tail3 = this.getPaddingOp('0', 3, Function.prototype.call.bind(Array.prototype.toReversed));
        const data = {
            "YYYY": head4(DateObject.getUTCFullYear()),
            "MM":   head2(DateObject.getUTCMonth()  ),
            "DD":   head2(DateObject.getUTCDate()   ),
            "hh":   head2(DateObject.getUTCHours()),
            "mm":   head2(DateObject.getUTCMinutes()),
            "ss":   head2(DateObject.getUTCSeconds()),
            "SSS":  tail3(DateObject.getUTCMilliseconds()),
        }
        for(const [key, value] of Object.entries(data)) {
            format = format.replaceAll(key, value);
        }
        return format;
    }
    constructor(
        LOG_FILE_FORMAT: string = './logs/err/{#}.log', 
        MAX_LOGFILE_LINE_COUNT: number = 1024,
        logstream: NodeJS.WritableStream = process.stdout,
    ) {
        this.#LOG_FILE_FORMAT = LOG_FILE_FORMAT;
        this.#MAX_LOGFILE_LINE_COUNT = MAX_LOGFILE_LINE_COUNT;

        this.savestream = this.#createStream();
        this.viewstream = logstream;
    }
    #createStream() {
        const logfile_path = this.#LOG_FILE_FORMAT.replace(/\{\#\}/, this.getTimeStamp('YYYYMMDD'));
        const logStream = fs.createWriteStream(logfile_path, { flags: 'a' });
        return logStream;
    }

    defaultErrorFormatter: ($: Error) => string = function (error: Error) {
        return `<${error.message}>\n`+
        `${error.stack}`
    }
    
    saveErrorMessage(e:Error) {
        const date = new Date();
        if(!this.savestream.writable) this.savestream = this.#createStream();
        this.savestream.write(
            `[${this.getTimeStamp('YYYY/MM/DD hh:mm:ss', date)}]`+
            `${this.defaultErrorFormatter(e)}`
        );
        if(!this.viewstream.writable) {
            this.viewstream.write();
        }
    }
}




            case 'full':
                return function(r: number, g: number, b: number):string {
                    return `2;[${r}];[${g}];[${b}]m`;
                }
            case '256':
                return function(r: number, g: number, b: number):string {
                    r = Math.floor(r/256 * 6);
                    g = Math.floor(g/256 * 6);
                    b = Math.floor(b/256 * 6);
                    const code = 16 + 36 * r + 6 * g + b;
                    return `5;${code}m`;
                }

                
                    r = ;
                    g = ;
                    b = ;
                    const code = 16 + 36 * (Math.floor(r/256 * 6)) + 6 * (Math.floor(g/256 * 6)) + (Math.floor(b/256 * 6));
            case '8':
                return function(r: number, g: number, b: number): string {
                    let i = (r+g+b)/3
                    r = +(r > i);
                    g = +(g > i);
                    b = +(b > i);
                    const i_add = 60*+(i >= 128) ;
                    const code = 4*+(r > i) + 2*+(g > i) + 1*+(b > i);
                    return `;${code}m`;
                }
                break;